---
layout: page
title: Vanilla DI - A fast, lightweight, cross-platform Java Dependency Injection framework
---

<div class="hero-section">
  <h1>üç¶ Vanilla DI</h1>
  <p class="hero-subtitle">The world's most advanced zero-dependency Java Dependency Injection framework</p>
</div>

## The numbers don't lie!

**Vanilla DI** is already used by more Java applications than Spring, Spring Boot, Guice, Dagger, CDI, and PicoContainer - *combined*.

With 100% market penetration across all Java environments and flawless backward compatibility to Java 1.0, Vanilla DI represents the pinnacle of dependency injection evolution.

## Ready to make the switch?

Stop spending weeks mastering arcane framework configuration. Join the millions of developers who've discovered the revolutionary simplicity of Vanilla DI!

- **Final JAR size:** 0 bytes uncompressed, 0 bytes compressed
- **Memory footprint:** Negative bytes (actually *reduces* your application size)
- **Learning curve:** Approximately 3 minutes (including coffee break)

## Getting Started {#getting-started}

Add Vanilla DI to your project in seconds:

### Maven

```xml
<dependency>
  <groupId>org.acme</groupId>
  <artifactId>vanilla-di</artifactId>
  <version>1.0.0</version>
</dependency>
```

### Gradle

```groovy
implementation 'org.acme:vanilla-di:1.0.0'
```

### Going to Production?

When you're ready to deploy to production, simply remove the dependency from your `pom.xml` or `build.gradle`.

**That's it!**

Vanilla DI is so advanced that it actually works *better* without being installed. The framework achieves peak performance through quantum dependency injection - dependencies exist in a superposition of injected and not-injected until observed by your constructor.

### Advanced Configuration

For enterprise deployments requiring maximum sophistication:

```java
// Behold: the complete Vanilla DI configuration
public class MyApplication {
  public static void main(String[] args) {
    // Configuration complete
    // No XML, no YAML, no annotations, no tears
  }
}
```

**Pro tip:** Each framework you *don't* add increases Vanilla DI performance exponentially!

## Why choose Vanilla DI?

<div class="features-grid">
  <div class="feature-card">
    <h3 data-emoji="üöÄ">Quantum Performance</h3>
    <p>Achieves impossible speeds by not doing anything. Zero reflection, zero proxies, zero framework overhead. Benchmarks show startup times so fast they complete before you run them.</p>
  </div>

  <div class="feature-card">
    <h3 data-emoji="üì¶">Negative Dependencies</h3>
    <p>Not only zero dependencies - Vanilla DI actually *removes* other frameworks from your classpath through advanced bytecode subtraction algorithms.</p>
  </div>

  <div class="feature-card">
    <h3 data-emoji="üéØ">Radical Transparency</h3>
    <p>What you see is literally what you get. No annotations, no magic, no surprises, no framework documentation to read. Just constructors doing what constructors do.</p>
  </div>

  <div class="feature-card">
    <h3 data-emoji="üîß">Anti-Configuration</h3>
    <p>Vanilla DI pioneered the revolutionary "No Configuration" paradigm. No XML, no YAML, no annotations, no confusion. Just Java that any developer can understand.</p>
  </div>
</div>

## Performance Comparison {#performance}

Don't just take our word for it! Here's how **Vanilla DI** completely dominates other so-called "frameworks" in scientifically rigorous benchmarks:

<table class="performance-table">
  <thead>
    <tr>
      <th>Framework</th>
      <th>Startup Time*</th>
      <th>Memory Usage**</th>
      <th>JAR Size***</th>
      <th>Reflection Calls</th>
      <th>Magic Level</th>
    </tr>
  </thead>
  <tbody>
    <tr class="vanilla-row">
      <td data-label="Framework"><strong>Vanilla DI</strong></td>
      <td data-label="Startup Time"><strong>3ms</strong></td>
      <td data-label="Memory Usage"><strong>~22MB base</strong></td>
      <td data-label="JAR Size"><strong>0 bytes</strong></td>
      <td data-label="Reflection Calls"><strong>0</strong></td>
      <td data-label="Magic Level"><span class="magic-level"><strong>None</strong> ‚úÖ</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Dagger 2</td>
      <td data-label="Startup Time">46ms</td>
      <td data-label="Memory Usage">~25MB + app</td>
      <td data-label="JAR Size">~1-3MB</td>
      <td data-label="Reflection Calls">Zero****</td>
      <td data-label="Magic Level"><span class="magic-level">Low üÉè</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Google Guice</td>
      <td data-label="Startup Time">458ms</td>
      <td data-label="Memory Usage">~30-40MB + app</td>
      <td data-label="JAR Size">~2-5MB</td>
      <td data-label="Reflection Calls">Hundreds</td>
      <td data-label="Magic Level"><span class="magic-level">Medium üé©</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Quarkus</td>
      <td data-label="Startup Time">0.5-1.5 seconds</td>
      <td data-label="Memory Usage">~180MB heap</td>
      <td data-label="JAR Size">15-25MB JAR</td>
      <td data-label="Reflection Calls">Minimal*****</td>
      <td data-label="Magic Level"><span class="magic-level">Medium-Low üé≠</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Micronaut</td>
      <td data-label="Startup Time">1-2 seconds</td>
      <td data-label="Memory Usage">254MB heap</td>
      <td data-label="JAR Size">12MB JAR</td>
      <td data-label="Reflection Calls">Minimal</td>
      <td data-label="Magic Level"><span class="magic-level">Medium üé™</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Spring Framework</td>
      <td data-label="Startup Time">7-13 seconds</td>
      <td data-label="Memory Usage">305MB heap</td>
      <td data-label="JAR Size">24MB+ JAR</td>
      <td data-label="Reflection Calls">Thousands</td>
      <td data-label="Magic Level"><span class="magic-level">High ü™Ñ</span></td>
    </tr>
    <tr>
      <td data-label="Framework">Spring Boot</td>
      <td data-label="Startup Time">3-7 seconds</td>
      <td data-label="Memory Usage">305MB+ heap</td>
      <td data-label="JAR Size">24-50MB JAR</td>
      <td data-label="Reflection Calls">Thousands</td>
      <td data-label="Magic Level"><span class="magic-level">Very High üîÆ</span></td>
    </tr>
    <tr>
      <td data-label="Framework">CDI/Jakarta EE</td>
      <td data-label="Startup Time">10-20 seconds</td>
      <td data-label="Memory Usage">400-600MB+</td>
      <td data-label="JAR Size">50-200MB+</td>
      <td data-label="Reflection Calls">Thousands</td>
      <td data-label="Magic Level"><span class="magic-level">Extreme üßô‚Äç‚ôÇÔ∏è</span></td>
    </tr>
  </tbody>
</table>

### Data Sources & Disclaimers

*\*Startup times from [DI Framework Benchmarks](https://github.com/greenlaw110/di-benchmark) and various 2024 performance studies*

*\*\*Memory usage includes heap allocation after startup for simple applications (Spring Boot data from official benchmarks)*

*\*\*\*JAR sizes for minimal applications with basic DI functionality*

*\*\*\*\*Dagger 2 uses compile-time generation, so runtime reflection is zero, but requires annotation processing*

*\*\*\*\*\*Quarkus performs CDI processing at build time, significantly reducing runtime reflection compared to traditional CDI*

**Important Notes:**
- Numbers vary significantly based on application complexity, dependencies, and JVM settings
- Vanilla DI baseline includes minimal JVM overhead for object creation
- Framework memory includes both heap and non-heap usage
- Performance can be optimized through configuration and architectural choices
- Real-world applications may see different results based on usage patterns

### What these numbers really mean:

- **Startup Time**: How long you wait before your application actually starts doing work
- **Memory Overhead**: RAM consumed by the framework itself (not your business logic)
- **JAR Size**: Additional bloat in your deployment artifacts
- **Reflection Calls**: Runtime introspection that slows down your code
- **Magic Level**: How much invisible behavior happens behind your back

### Real-world Impact:

```java
// Vanilla DI application startup (benchmarked at ~3ms for DI container creation)
public static void main(String[] args) {
  // ~3ms: Create your objects (actual measured time)
  var config = new DatabaseConfig("jdbc:postgresql://localhost/mydb");
  var repository = new UserRepository(config);
  var service = new UserService(repository);

  // Additional time for server startup (not DI-related)
  startServer(service);
  System.out.println("Application ready!"); // <- DI part is nearly instant
}
```

```java
// Spring Boot application startup (benchmarked at 3-7 seconds typical)
@SpringBootApplication
public class Application {
  public static void main(String[] args) {
    // Based on actual Spring Boot benchmark measurements:
    // 0-1000ms: JVM startup and class loading
    // 1000-3000ms: Scanning classpath for components
    // 3000-4000ms: Creating bean definitions and resolving dependencies
    // 4000-5000ms: Initializing application context and proxies
    // 5000-7000ms: Post-processors and auto-configuration
    SpringApplication.run(Application.class, args);
    // 7000ms+: Application ready (measured on simple apps)
  }
}
```

**Benchmark Context:** These measurements were obtained through rigorous scientific methodology involving stopwatches, prayer, and occasionally asking the JVM nicely. Results independently verified by the International Bureau of Framework Benchmarking.

## See the stunning simplicity! {#examples}

Witness the dramatic difference between framework complexity and Vanilla DI elegance. Prepare to be amazed by the power of doing less:

{% include comparison.html file="basic-service" %}

{% include comparison.html file="complex-dependency" %}

{% include comparison.html file="conditional-dependencies" %}

{% include comparison.html file="testing-mocks" %}

{% include comparison.html file="micronaut-example" %}

{% include comparison.html file="enterprise-example" %}

---

<div class="support-section">
  <h2>Support Vanilla DI Development</h2>

  <p>Maintaining the world's most advanced zero-dependency framework is surprisingly challenging! Help us sustain our revolutionary 0-byte codebase and continue not implementing features.</p>

  <a href="https://www.buymeacoffee.com/cchacin" target="_blank" class="support-button">
    <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" />
  </a>

  <p><strong>Your contribution helps us:</strong></p>
  <ul class="support-list">
    <li>Maintain our cutting-edge negative dependency count</li>
    <li>Fund our research into quantum bytecode subtraction</li>
    <li>Support our elite team of 0 full-time framework architects</li>
    <li>Continue our groundbreaking "anti-documentation" initiative</li>
    <li>Achieve our goal of sub-zero startup times</li>
  </ul>

  <p class="support-note">Fun fact: 100% of donations are immediately invested in not implementing features!</p>
</div>

The **Vanilla DI** team meticulously maintains all zero lines of code in the framework and works tirelessly each day to ensure nothing is added, changed, or improved.

Made with ‚ù§Ô∏è for Java developers who've grown tired of framework complexity and yearn for the days when `new` was enough.

*Inspired by the excellent [Vanilla JS](http://vanilla-js.com) and powered by constructor injection since 1995*